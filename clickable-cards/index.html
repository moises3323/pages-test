<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Clickable Cards</title>
    <style>
      :root {
        --card-width: 170px;
        --card-height: 260px;
        --gap: 16px;
      }

      body {
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: #fff;
        color: #111827;
      }

      .wrap {
        padding: 24px;
      }

      .cards-container {
        display: flex;
        justify-content: center;
        gap: var(--gap);
        flex-wrap: wrap;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        padding: 40px 0;
      }

      .cards-container::-webkit-scrollbar {
        display: none;
      }

      .flip-container {
        perspective: 1000px;
        width: var(--card-width);
        height: var(--card-height);
        flex: 0 0 auto;
        border: 0;
        padding: 0;
        background: transparent;
        cursor: pointer;
        filter: drop-shadow(0 18px 30px rgba(15, 23, 42, 0.18));
        transition: transform 0.2s ease;
      }

      .flip-container:hover,
      .flip-container:focus-visible {
        transform: scale(1.02);
      }

      .flip-container:focus-visible {
        outline: 3px solid #2563eb;
        outline-offset: 4px;
        border-radius: 10px;
      }

      .flipper {
        display: inline-grid;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.6s;
        height: var(--card-height);
        width: var(--card-width);
      }

      .flip-container.is-flipped .flipper {
        transform: rotateY(180deg);
      }

      .front,
      .back {
        grid-area: 1 / 1;
        backface-visibility: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        overflow: hidden;
        height: var(--card-height);
        width: var(--card-width);
        padding: 16px;
        box-sizing: border-box;
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }

      .front {
        background: radial-gradient(
            circle at 15% 20%,
            rgba(255, 255, 255, 0.9),
            rgba(255, 255, 255, 0.3) 45%,
            transparent 60%
          ),
          linear-gradient(145deg, #f8fafc 0%, #e2e8f0 60%, #e5e7eb 100%);
      }

      .front-img {
        height: 100%;
        width: 100%;
        object-fit: contain;
        display: block;
      }

      .back {
        background: linear-gradient(160deg, #ffffff 0%, #f1f5f9 45%, #e2e8f0 100%);
        color: #111827;
        transform: rotateY(180deg);
        padding: 14px;
        box-sizing: border-box;
        text-align: center;
        line-height: 1.3;
        font-size: 16px;
        overflow-wrap: anywhere;
      }

      .hint {
        font-size: 12px;
        color: #6b7280;
        text-align: center;
        margin-top: 12px;
        overflow-wrap: anywhere;
      }

      .hint:empty {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div id="cards" class="cards-container" aria-label="Clickable cards"></div>
      <div id="hint" class="hint"></div>
    </div>

    <script>
      (async function () {
        const DEFAULT_CARDS = [
          {
            image:
              "https://blog.redmondequine.com/hubfs/Raspberry%20and%20chasteberry%20for%20horses.jpg",
            text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
          },
          {
            image:
              "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1200&q=60",
            text: "Personaliza este texto usando ?text2=...",
          },
          {
            image:
              "https://images.unsplash.com/photo-1520975916090-3105956dac38?auto=format&fit=crop&w=1200&q=60",
            text: "También puedes cambiar la imagen con ?img3=...",
          },
        ];

        function normalizeParamString(raw) {
          return String(raw || "")
            .replace(/^\?/, "")
            .replace(/^#/, "")
            .replace(/&amp;/gi, "&")
            .replace(/;/g, "&");
        }

        const normalizedSearch = normalizeParamString(window.location.search);
        const normalizedHash = normalizeParamString(window.location.hash);

        const combinedParams = [normalizedSearch, normalizedHash].filter(Boolean).join("&");
        const rawParams = new URLSearchParams(combinedParams);
        const params = new URLSearchParams();

        for (const [key, value] of rawParams.entries()) {
          let normalizedKey = String(key);
          while (normalizedKey.toLowerCase().startsWith("amp;")) {
            normalizedKey = normalizedKey.slice(4);
          }
          if (!params.has(normalizedKey)) params.set(normalizedKey, value);
        }

        function coalesce(...values) {
          for (const value of values) {
            if (value === null || value === undefined) continue;
            const trimmed = String(value).trim();
            if (trimmed) return trimmed;
          }
          return "";
        }

        function safeParseCardsParam(value) {
          if (!value) return null;
          try {
            const parsed = JSON.parse(value);
            if (!Array.isArray(parsed)) return null;
            return parsed.slice(0, 3).map((card) => ({
              image: typeof card?.image === "string" ? card.image : "",
              text: typeof card?.text === "string" ? card.text : "",
            }));
          } catch {
            return null;
          }
        }

        function splitList(raw) {
          if (!raw) return [];
          return String(raw)
            .split(/[|,]/)
            .map((item) => item.trim())
            .filter(Boolean);
        }

        const CANVAS_BASE = "https://canvas.instructure.com";

        function extractFirstUrlLikeValue(input) {
          const value = String(input || "").trim();
          if (!value) return "";
          const match = value.match(/https?:\/\/[^\s"'<>]+/i);
          if (match) return match[0];
          return value;
        }

        function normalizeCanvasUrl(value) {
          if (!value) return "";
          if (value.startsWith("//canvas.instructure.com"))
            return `https:${value}`;
          if (value.startsWith("/courses/") || value.startsWith("/files/"))
            return `${CANVAS_BASE}${value}`;
          if (value.startsWith("canvas.instructure.com/"))
            return `https://${value}`;
          return value;
        }

        function base64UrlToString(raw) {
          if (!raw) return "";
          let input = String(raw).replace(/-/g, "+").replace(/_/g, "/");
          while (input.length % 4) input += "=";
          try {
            return atob(input);
          } catch {
            return "";
          }
        }

        function parseBundle(raw) {
          if (!raw) return null;
          const decoded = base64UrlToString(decodeURIComponent(raw));
          if (!decoded) return null;
          try {
            const parsed = JSON.parse(decoded);
            const images = Array.isArray(parsed?.images)
              ? parsed.images.map((x) => (typeof x === "string" ? x : "")).filter(Boolean)
              : [];
            const texts = Array.isArray(parsed?.texts)
              ? parsed.texts.map((x) => (typeof x === "string" ? x : "")).filter(Boolean)
              : [];
            if (!images.length && !texts.length) return null;
            return { images, texts };
          } catch {
            return null;
          }
        }

        function getSafeImageUrl(rawUrl) {
          const value = normalizeCanvasUrl(extractFirstUrlLikeValue(rawUrl));
          if (!value) return "";
          try {
            const url = new URL(value, window.location.href);
            if (url.protocol === "http:" || url.protocol === "https:")
              return url.href;
            if (url.protocol === "data:") {
              const lower = url.href.toLowerCase();
              if (lower.startsWith("data:image/")) return url.href;
              return "";
            }
            if (url.protocol === "blob:") return url.href;
            return "";
          } catch {
            return "";
          }
        }

        function buildCardsFromParams() {
          const bundle = parseBundle(params.get("bundle") || params.get("b"));
          const cardsFromJson = safeParseCardsParam(params.get("cards"));
          if (cardsFromJson && cardsFromJson.length) {
            return DEFAULT_CARDS.map((fallback, idx) => {
              const fromParam = cardsFromJson[idx] || {};
              return {
                image: coalesce(getSafeImageUrl(fromParam.image), fallback.image),
                text: coalesce(fromParam.text, fallback.text),
              };
            });
          }

          const listImages = splitList(params.get("img") || params.get("images"));
          const listTexts = splitList(params.get("text") || params.get("texts"));

          const cards = [];
          for (let i = 1; i <= 3; i++) {
            const image = coalesce(
              getSafeImageUrl(bundle?.images?.[i - 1]),
              getSafeImageUrl(listImages[i - 1]),
              getSafeImageUrl(params.get(`img${i}`)),
              getSafeImageUrl(params.get(`image${i}`)),
              DEFAULT_CARDS[i - 1].image,
            );
            const text = coalesce(
              bundle?.texts?.[i - 1],
              listTexts[i - 1],
              params.get(`text${i}`),
              params.get(`back${i}`),
              DEFAULT_CARDS[i - 1].text,
            );
            cards.push({ image, text });
          }
          return cards;
        }

        async function fetchPreset(key) {
          if (!key) return null;
          try {
            const response = await fetch("presets.json", { cache: "no-store" });
            if (!response.ok) return null;
            const presets = await response.json();
            return presets?.[key] || null;
          } catch {
            return null;
          }
        }

        function normalizePreset(preset) {
          if (!preset) return null;
          // Soporta formato preferido: array de objetos [{ image, text }, ...]
          if (Array.isArray(preset)) {
            const targetLength = Math.max(DEFAULT_CARDS.length, preset.length);
            return Array.from({ length: targetLength }, (_, idx) => {
              const item = preset[idx] || {};
              return {
                image: typeof item?.image === "string" ? item.image : "",
                text: typeof item?.text === "string" ? item.text : "",
              };
            });
          }
          // Compatibilidad: objeto con arrays images/texts
          if (typeof preset === "object") {
            const images = Array.isArray(preset.images) ? preset.images : [];
            const texts = Array.isArray(preset.texts) ? preset.texts : [];
            const targetLength = Math.max(
              DEFAULT_CARDS.length,
              images.length,
              texts.length,
            );
            return Array.from({ length: targetLength }, (_, idx) => ({
              image: typeof images[idx] === "string" ? images[idx] : "",
              text: typeof texts[idx] === "string" ? texts[idx] : "",
            }));
          }
          return null;
        }

        function normalizeCards(rawCards) {
          const cards = Array.isArray(rawCards) ? rawCards : [];
          const targetLength = Math.max(DEFAULT_CARDS.length, cards.length);
          return Array.from({ length: targetLength }, (_, idx) => {
            const fallback = DEFAULT_CARDS[idx] || {};
            const candidate = cards[idx] || {};
            const candidateImage =
              typeof candidate?.image === "string" ? candidate.image : "";
            const candidateText = typeof candidate?.text === "string" ? candidate.text : "";
            return {
              image: coalesce(getSafeImageUrl(candidateImage), fallback.image),
              text: coalesce(candidateText, fallback.text),
            };
          });
        }

        function getCardHeightPx() {
          const raw = getComputedStyle(document.documentElement).getPropertyValue(
            "--card-height",
          );
          const value = parseFloat(raw);
          return Number.isFinite(value) && value > 0 ? value : 300;
        }

        function createCardElement(card, index) {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "flip-container";
          button.setAttribute(
            "aria-label",
            `Card ${index + 1}. Click para voltear.`,
          );

          const flipper = document.createElement("div");
          flipper.className = "flipper";

          const front = document.createElement("div");
          front.className = "front";

          const img = document.createElement("img");
          img.className = "front-img";
          img.alt = "";
          img.decoding = "async";
          img.loading = "lazy";
          img.src = card.image;

          front.appendChild(img);

          const back = document.createElement("div");
          back.className = "back";
          back.textContent = card.text;

          flipper.appendChild(front);
          flipper.appendChild(back);
          button.appendChild(flipper);

          button.addEventListener("click", () => {
            button.classList.toggle("is-flipped");
          });

          return button;
        }

        const container = document.getElementById("cards");
        const hintEl = document.getElementById("hint");
        hintEl.textContent = "";

        function renderCards(rawCards) {
          const cards = normalizeCards(rawCards);
          container.replaceChildren(
            ...cards.map((card, index) => createCardElement(card, index)),
          );
        }

        renderCards(buildCardsFromParams());

        const hasCustomParams =
          params.has("cards") ||
          params.has("img1") ||
          params.has("img2") ||
          params.has("img3") ||
          params.has("image1") ||
          params.has("image2") ||
          params.has("image3") ||
          params.has("text1") ||
          params.has("text2") ||
          params.has("text3") ||
          params.has("back1") ||
          params.has("back2") ||
          params.has("back3");

        // Hint default eliminado a petición del usuario.

        window.addEventListener("message", (event) => {
          const data = event?.data;
          if (!data || typeof data !== "object") return;
          if (data.type !== "clickable-cards:set") return;
          if (!Array.isArray(data.cards)) return;
          hintEl.textContent = "";
          renderCards(data.cards);
        });

        const presetKey = params.get("preset") || params.get("key");
        if (presetKey) {
          const preset = await fetchPreset(presetKey);
          if (preset) {
            renderCards(normalizePreset(preset));
          } else {
            hintEl.textContent = `No se encontró el preset "${presetKey}".`;
          }
        }
      })();
    </script>
  </body>
</html>
