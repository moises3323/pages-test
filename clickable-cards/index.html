<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Clickable Cards</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Montserrat:wght@600;700&display=swap");
      :root {
        --card-width: 210px;
        --card-height: 300px;
        --gap: 18px;
        --card-radius: 18px;
        --border-color: #9aa8b1;
        --accent: #ef4a3a;
        --paper: #ffffff;
        --cream: #ffffff;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        font-family: "Avenir", "Avenir Next", "Avenir Next LT Pro", "Nunito", "Trebuchet MS",
          "Segoe UI", sans-serif;
        color: #2f2a25;
      }

      .wrap {
        padding: 28px 20px 36px;
      }

      .cards-container {
        display: flex;
        justify-content: center;
        gap: var(--gap);
        flex-wrap: wrap;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        padding: 36px 0;
        background: transparent;
      }

      .cards-container::-webkit-scrollbar {
        display: none;
      }

      .flip-container {
        perspective: 1000px;
        width: var(--card-width);
        height: var(--card-height);
        flex: 0 0 auto;
        border: 0;
        padding: 0;
        background: transparent;
        cursor: pointer;
        filter: drop-shadow(var(--shadow));
        transition: transform 0.2s ease, filter 0.2s ease;
      }

      .flip-container:hover,
      .flip-container:focus-visible {
        transform: translateY(-2px);
      }

      .flip-container:focus-visible {
        outline: 3px solid rgba(239, 74, 58, 0.45);
        outline-offset: 4px;
        border-radius: var(--card-radius);
      }

      .flipper {
        display: inline-grid;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.6s;
        height: var(--card-height);
        width: var(--card-width);
      }

      .flip-container.is-flipped .flipper {
        transform: rotateY(180deg);
      }

      .front,
      .back {
        grid-area: 1 / 1;
        backface-visibility: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: var(--card-radius);
        overflow: hidden;
        height: var(--card-height);
        width: var(--card-width);
        padding: 18px 16px;
        box-sizing: border-box;
        border: 2px solid var(--border-color);
        background: var(--paper);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
      }

      .front {
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 12px;
        text-align: center;
        background: var(--paper);
      }

      .front-title {
        font-family: "Montserrat", "Avenir Next", "Avenir", "Segoe UI", sans-serif;
        font-size: 19px;
        font-weight: 700;
        color: var(--accent);
        line-height: 1.1;
        text-transform: uppercase;
        grid-row: 1;
        width: 100%;
      }

      .front-title:empty {
        display: none;
      }

      .front-illustration {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        grid-row: 2;
      }

      .front-img {
        max-height: 150px;
        max-width: 100%;
        object-fit: contain;
        display: block;
      }

      .front-name {
        border-top: 1px solid var(--border-color);
        padding-top: 10px;
        font-size: 13px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-weight: 700;
        color: #3a3530;
        grid-row: 3;
        width: 100%;
      }

      .front-name:empty {
        display: none;
      }

      .back {
        background: var(--cream);
        color: #3a3530;
        transform: rotateY(180deg);
        padding: 20px 18px 18px;
        box-sizing: border-box;
        text-align: center;
        line-height: 1.35;
        font-size: 13px;
        overflow-wrap: anywhere;
        flex-direction: column;
        gap: 12px;
      }

      .back-title {
        font-family: "Montserrat", "Avenir Next", "Avenir", "Segoe UI", sans-serif;
        font-size: 18px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--accent);
        margin-top: 2px;
      }

      .back-description {
        font-size: 13px;
      }

      .hint {
        font-size: 12px;
        color: #6b7280;
        text-align: center;
        margin-top: 12px;
        overflow-wrap: anywhere;
      }

      .hint:empty {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div id="cards" class="cards-container" aria-label="Clickable cards"></div>
      <div id="hint" class="hint"></div>
    </div>

    <script>
      (async function () {
        const DEFAULT_CARDS = [
          {
            image: "https://canvas.instructure.com/courses/11992150/files/325594601/preview",
            title: "The Steward of the Land",
            name: "Silas",
            text: "Re-Lyte keeps me hydrated as I work in the field, and I love Real Salt and seasonings on the eggs, meat, and vegetables I raise!",
          },
          {
            image: "https://canvas.instructure.com/courses/11992150/files/321895982/preview",
            title: "Peak Performer",
            name: "Cedar",
            text: "Re-Lyte products help me perform at my best! I also love Redmond's natural seasonings and care products, so I know what I'm putting on or in my body.",
          },
          {
            image: "https://canvas.instructure.com/courses/11992150/files/321895824/preview",
            title: "Optimized Living Enthusiast",
            name: "Maya",
            text: "I love Redmond Living products because I know they're made with nourishing, responsibly sourced ingredients that feel good on and in my body, helping me live my best life.",
          },
          {
            image: "https://canvas.instructure.com/courses/11992150/files/325594429/preview",
            title: "The Master of the Meal",
            name: "Chef Shawna",
            text: "Redmond's Real Salt and seasonings are unparalleled! I love these products, whether I'm preparing a quick meal for myself or an elaborate twelve-course meal for a dinner party.",
          },
          {
            image: "https://canvas.instructure.com/courses/11992150/files/321896079/preview",
            title: "Conscious Caretaker",
            name: "Caleb",
            text: "My kids love Relyte, and so do I! Redmond products help us stay hydrated and healthy, allowing us to feel our best and spend quality time together.",
          },
        ];

        function normalizeParamString(raw) {
          return String(raw || "")
            .replace(/^\?/, "")
            .replace(/^#/, "")
            .replace(/&amp;/gi, "&")
            .replace(/;/g, "&");
        }

        const normalizedSearch = normalizeParamString(window.location.search);
        const normalizedHash = normalizeParamString(window.location.hash);

        const combinedParams = [normalizedSearch, normalizedHash].filter(Boolean).join("&");
        const rawParams = new URLSearchParams(combinedParams);
        const params = new URLSearchParams();

        for (const [key, value] of rawParams.entries()) {
          let normalizedKey = String(key);
          while (normalizedKey.toLowerCase().startsWith("amp;")) {
            normalizedKey = normalizedKey.slice(4);
          }
          if (!params.has(normalizedKey)) params.set(normalizedKey, value);
        }

        function coalesce(...values) {
          for (const value of values) {
            if (value === null || value === undefined) continue;
            const trimmed = String(value).trim();
            if (trimmed) return trimmed;
          }
          return "";
        }

        function safeParseCardsParam(value) {
          if (!value) return null;
          try {
            const parsed = JSON.parse(value);
            if (!Array.isArray(parsed)) return null;
            return parsed.slice(0, DEFAULT_CARDS.length).map((card) => ({
              image: typeof card?.image === "string" ? card.image : "",
              title: typeof card?.title === "string" ? card.title : "",
              name: typeof card?.name === "string" ? card.name : "",
              description: typeof card?.description === "string" ? card.description : "",
              text: typeof card?.text === "string" ? card.text : "",
            }));
          } catch {
            return null;
          }
        }

        function splitList(raw) {
          if (!raw) return [];
          return String(raw)
            .split(/[|,]/)
            .map((item) => item.trim())
            .filter(Boolean);
        }

        const CANVAS_BASE = "https://canvas.instructure.com";

        function canvasPreviewToDownloadUrl(value) {
          const raw = String(value || "").trim();
          if (!raw) return "";
          const normalized = raw
            .replace(/^\/\/canvas\.instructure\.com/i, "https://canvas.instructure.com")
            .replace(/^canvas\.instructure\.com\//i, "https://canvas.instructure.com/");
          if (!/^https?:\/\/canvas\.instructure\.com\//i.test(normalized)) return raw;
          try {
            const url = new URL(normalized);
            if (!/\/preview\/?$/.test(url.pathname)) return raw;
            url.pathname = url.pathname.replace(/\/preview\/?$/, "/download");
            if (!url.searchParams.has("download_frd")) {
              url.searchParams.set("download_frd", "1");
            }
            return url.toString();
          } catch {
            return raw;
          }
        }

        function extractFirstUrlLikeValue(input) {
          const value = String(input || "").trim();
          if (!value) return "";
          const match = value.match(/https?:\/\/[^\s"'<>]+/i);
          if (match) return match[0];
          return value;
        }

        function normalizeCanvasUrl(value) {
          if (!value) return "";
          if (value.startsWith("//canvas.instructure.com"))
            return canvasPreviewToDownloadUrl(`https:${value}`);
          if (value.startsWith("/courses/") || value.startsWith("/files/"))
            return canvasPreviewToDownloadUrl(`${CANVAS_BASE}${value}`);
          if (value.startsWith("canvas.instructure.com/"))
            return canvasPreviewToDownloadUrl(`https://${value}`);
          return canvasPreviewToDownloadUrl(value);
        }

        function base64UrlToString(raw) {
          if (!raw) return "";
          let input = String(raw).replace(/-/g, "+").replace(/_/g, "/");
          while (input.length % 4) input += "=";
          try {
            return atob(input);
          } catch {
            return "";
          }
        }

        function parseBundle(raw) {
          if (!raw) return null;
          const decoded = base64UrlToString(decodeURIComponent(raw));
          if (!decoded) return null;
          try {
            const parsed = JSON.parse(decoded);
            const images = Array.isArray(parsed?.images)
              ? parsed.images.map((x) => (typeof x === "string" ? x : "")).filter(Boolean)
              : [];
            const texts = Array.isArray(parsed?.texts)
              ? parsed.texts.map((x) => (typeof x === "string" ? x : "")).filter(Boolean)
              : [];
            if (!images.length && !texts.length) return null;
            return { images, texts };
          } catch {
            return null;
          }
        }

        function getSafeImageUrl(rawUrl) {
          const value = normalizeCanvasUrl(extractFirstUrlLikeValue(rawUrl));
          if (!value) return "";
          try {
            const url = new URL(value, window.location.href);
            if (url.protocol === "http:" || url.protocol === "https:")
              return url.href;
            if (url.protocol === "data:") {
              const lower = url.href.toLowerCase();
              if (lower.startsWith("data:image/")) return url.href;
              return "";
            }
            if (url.protocol === "blob:") return url.href;
            return "";
          } catch {
            return "";
          }
        }

        function buildCardsFromParams() {
          const bundle = parseBundle(params.get("bundle") || params.get("b"));
          const cardsFromJson = safeParseCardsParam(params.get("cards"));
          if (cardsFromJson && cardsFromJson.length) {
            return DEFAULT_CARDS.map((fallback, idx) => {
              const fromParam = cardsFromJson[idx] || {};
              return {
                image: coalesce(getSafeImageUrl(fromParam.image), fallback.image),
                title: typeof fromParam?.title === "string" ? fromParam.title : "",
                name: typeof fromParam?.name === "string" ? fromParam.name : "",
                description: coalesce(fromParam.description, fromParam.text, fallback.text),
                text: coalesce(fromParam.text, fromParam.description, fallback.text),
              };
            });
          }

          const listImages = splitList(params.get("img") || params.get("images"));
          const listTexts = splitList(params.get("text") || params.get("texts"));

          const cards = [];
          for (let i = 1; i <= DEFAULT_CARDS.length; i++) {
            const image = coalesce(
              getSafeImageUrl(bundle?.images?.[i - 1]),
              getSafeImageUrl(listImages[i - 1]),
              getSafeImageUrl(params.get(`img${i}`)),
              getSafeImageUrl(params.get(`image${i}`)),
              DEFAULT_CARDS[i - 1].image,
            );
            const text = coalesce(
              bundle?.texts?.[i - 1],
              listTexts[i - 1],
              params.get(`text${i}`),
              params.get(`back${i}`),
              DEFAULT_CARDS[i - 1].text,
            );
            cards.push({ image, text });
          }
          return cards;
        }

        async function fetchPreset(key) {
          if (!key) return { preset: null, error: "missing-key" };
          try {
            const response = await fetch("presets.json", { cache: "no-store" });
            if (!response.ok) return { preset: null, error: "http-error" };
            const presets = await response.json();
            return { preset: presets?.[key] || null, error: null };
          } catch {
            return { preset: null, error: "load-failed" };
          }
        }

        function normalizePreset(preset) {
          if (!preset) return null;
          // Soporta formato preferido: array de objetos [{ image, title, description, text }, ...]
          if (Array.isArray(preset)) {
            const targetLength = Math.max(DEFAULT_CARDS.length, preset.length);
            return Array.from({ length: targetLength }, (_, idx) => {
              const item = preset[idx] || {};
              const title = typeof item?.title === "string" ? item.title : "";
              const name = typeof item?.name === "string" ? item.name : "";
              const description =
                typeof item?.description === "string" ? item.description : "";
              const text = typeof item?.text === "string" ? item.text : "";
              return {
                image: typeof item?.image === "string" ? item.image : "",
                title,
                name,
                description: coalesce(description, text),
                text: coalesce(text, description),
              };
            });
          }
          // Compatibilidad: objeto con arrays images/texts
          if (typeof preset === "object") {
            const images = Array.isArray(preset.images) ? preset.images : [];
            const texts = Array.isArray(preset.texts) ? preset.texts : [];
            const targetLength = Math.max(
              DEFAULT_CARDS.length,
              images.length,
              texts.length,
            );
            return Array.from({ length: targetLength }, (_, idx) => ({
              image: typeof images[idx] === "string" ? images[idx] : "",
              title: "",
              name: "",
              description: typeof texts[idx] === "string" ? texts[idx] : "",
              text: typeof texts[idx] === "string" ? texts[idx] : "",
            }));
          }
          return null;
        }

        function normalizeCards(rawCards) {
          const cards = Array.isArray(rawCards) ? rawCards : [];
          const targetLength = Math.max(DEFAULT_CARDS.length, cards.length);
          return Array.from({ length: targetLength }, (_, idx) => {
            const fallback = DEFAULT_CARDS[idx] || {};
            const candidate = cards[idx] || {};
            const candidateImage =
              typeof candidate?.image === "string" ? candidate.image : "";
            const candidateTitle =
              typeof candidate?.title === "string" ? candidate.title : "";
            const candidateName =
              typeof candidate?.name === "string" ? candidate.name : "";
            const candidateDescription =
              typeof candidate?.description === "string" ? candidate.description : "";
            const candidateText =
              typeof candidate?.text === "string" ? candidate.text : "";
            const fallbackTitle =
              typeof fallback?.title === "string" ? fallback.title : "";
            const fallbackName =
              typeof fallback?.name === "string" ? fallback.name : "";
            const fallbackDescription =
              typeof fallback?.description === "string" ? fallback.description : "";
            const fallbackText =
              typeof fallback?.text === "string" ? fallback.text : "";
            return {
              image: coalesce(getSafeImageUrl(candidateImage), fallback.image),
              title: coalesce(candidateTitle, fallbackTitle),
              name: coalesce(candidateName, fallbackName),
              description: coalesce(
                candidateDescription,
                candidateText,
                fallbackDescription,
                fallbackText,
              ),
              text: coalesce(candidateText, candidateDescription, fallbackText, fallbackDescription),
            };
          });
        }

        function splitTitleAndName(card) {
          const rawTitle = coalesce(card?.title);
          const rawName = coalesce(card?.name);
          if (rawName || !rawTitle) return { title: rawTitle, name: rawName };
          const separators = [" - ", " — ", " – ", ": "];
          for (const separator of separators) {
            const index = rawTitle.indexOf(separator);
            if (index > 0) {
              return {
                name: rawTitle.slice(0, index).trim(),
                title: rawTitle.slice(index + separator.length).trim(),
              };
            }
          }
          return { title: rawTitle, name: "" };
        }

        function getCardHeightPx() {
          const raw = getComputedStyle(document.documentElement).getPropertyValue(
            "--card-height",
          );
          const value = parseFloat(raw);
          return Number.isFinite(value) && value > 0 ? value : 300;
        }

        function createCardElement(card, index) {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "flip-container";
          button.setAttribute(
            "aria-label",
            `Card ${index + 1}. Click para voltear.`,
          );

          const flipper = document.createElement("div");
          flipper.className = "flipper";

          const front = document.createElement("div");
          front.className = "front";

          const { title: titleText, name: nameText } = splitTitleAndName(card);

          const frontTitle = document.createElement("div");
          frontTitle.className = "front-title";
          frontTitle.textContent = titleText;

          const illustration = document.createElement("div");
          illustration.className = "front-illustration";

          const img = document.createElement("img");
          img.className = "front-img";
          img.alt = nameText ? `${nameText} illustration` : "";
          img.decoding = "async";
          img.loading = "lazy";
          img.src = card.image;
          img.addEventListener("error", () => {
            const fallbackSrc = "../farm/assets/customer-placeholder.svg";
            const isCanvasImage =
              typeof card?.image === "string" &&
              /canvas\.instructure\.com/i.test(card.image);
            if (isCanvasImage && hintEl && !hintEl.dataset.canvasImageWarning) {
              hintEl.textContent =
                "Algunas imágenes de Canvas no cargaron. Usa URLs públicas/directas o archivos locales.";
              hintEl.dataset.canvasImageWarning = "1";
            }
            if (img.src !== new URL(fallbackSrc, window.location.href).href) {
              img.src = fallbackSrc;
            }
          });

          illustration.appendChild(img);

          const frontName = document.createElement("div");
          frontName.className = "front-name";
          frontName.textContent = nameText;

          front.appendChild(frontTitle);
          front.appendChild(illustration);
          front.appendChild(frontName);

          const back = document.createElement("div");
          back.className = "back";
          const descriptionText = coalesce(card?.description, card?.text);

          if (titleText) {
            const title = document.createElement("div");
            title.className = "back-title";
            title.textContent = titleText;
            back.appendChild(title);
          }

          if (descriptionText) {
            const description = document.createElement("div");
            description.className = "back-description";
            description.textContent = descriptionText;
            back.appendChild(description);
          }

          flipper.appendChild(front);
          flipper.appendChild(back);
          button.appendChild(flipper);

          button.addEventListener("click", () => {
            button.classList.toggle("is-flipped");
          });

          return button;
        }

        const container = document.getElementById("cards");
        const hintEl = document.getElementById("hint");
        hintEl.textContent = "";

        function renderCards(rawCards) {
          const cards = normalizeCards(rawCards);
          container.replaceChildren(
            ...cards.map((card, index) => createCardElement(card, index)),
          );
        }

        renderCards(buildCardsFromParams());

        const hasCustomParams =
          params.has("cards") ||
          params.has("img1") ||
          params.has("img2") ||
          params.has("img3") ||
          params.has("img4") ||
          params.has("img5") ||
          params.has("image1") ||
          params.has("image2") ||
          params.has("image3") ||
          params.has("image4") ||
          params.has("image5") ||
          params.has("text1") ||
          params.has("text2") ||
          params.has("text3") ||
          params.has("text4") ||
          params.has("text5") ||
          params.has("back1") ||
          params.has("back2") ||
          params.has("back3") ||
          params.has("back4") ||
          params.has("back5");

        // Hint default eliminado a petición del usuario.

        window.addEventListener("message", (event) => {
          const data = event?.data;
          if (!data || typeof data !== "object") return;
          if (data.type !== "clickable-cards:set") return;
          if (!Array.isArray(data.cards)) return;
          hintEl.textContent = "";
          renderCards(data.cards);
        });

        const presetKey = params.get("preset") || params.get("key");
        if (presetKey) {
          const { preset, error } = await fetchPreset(presetKey);
          if (preset) {
            renderCards(normalizePreset(preset));
          } else {
            const isFileProtocol = window.location.protocol === "file:";
            if (isFileProtocol && error === "load-failed") {
              hintEl.textContent =
                "No se pudo cargar presets.json desde file://. Abre esta página con un servidor local.";
            } else {
              hintEl.textContent = `No se encontró el preset "${presetKey}".`;
            }
          }
        }
      })();
    </script>
  </body>
</html>
